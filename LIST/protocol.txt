; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --no_integer_literal_pools --list -c --asm --interleave -o.\exec\protocol.o --asm_dir=.\LIST\ --list_dir=.\LIST\ --depend=.\exec\protocol.d --cpu=Cortex-M4.fp --apcs=interwork -Otime --diag_suppress=9931 -I.\STARTUP -I.\PERIPH -I..\PRG1 -I.\SOURCE -IF:\Program\Keil_v5\ARM\RV31\INC -IF:\Program\Keil_v5\ARM\CMSIS\Include -IF:\Program\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=524 -DEK_PP_0815_12_03 -DSTM32F429_439xx --omf_browse=.\exec\protocol.crf SOURCE\Protocol.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=1

                  Modbus04ExtMem PROC
;;;4      
;;;5      int32_t Modbus04ExtMem(int32_t Count, uint8_t *RxBuff, uint8_t *TxBuff, uint16_t *DataAddr, uint32_t DataLen) {
000000  b570              PUSH     {r4-r6,lr}
000002  4614              MOV      r4,r2
;;;6      int32_t i;
;;;7      int j;
;;;8      int k;	
;;;9      uint32_t Data;
;;;10     uint32_t Addr;	
;;;11     
;;;12     	if (Count!=8) return ModbusErr(0x03, RxBuff, TxBuff);
000004  f8ddc010          LDR      r12,[sp,#0x10]
000008  2808              CMP      r0,#8
00000a  d004              BEQ      |L1.22|
00000c  e8bd4070          POP      {r4-r6,lr}
000010  2003              MOVS     r0,#3
000012  f7ffbffe          B.W      ModbusErr
                  |L1.22|
;;;13     	
;;;14     	//Кол-во регистров 																				
;;;15     	i = (RxBuff[4] << 8) | RxBuff[5];	
000016  8888              LDRH     r0,[r1,#4]
000018  ba40              REV16    r0,r0
;;;16       if ((i <= 0) || (i > ((USART_Buff_length - 5) >> 1) )) return ModbusErr(0x02, RxBuff, TxBuff);
00001a  2800              CMP      r0,#0
00001c  dd01              BLE      |L1.34|
00001e  283d              CMP      r0,#0x3d
000020  dd04              BLE      |L1.44|
                  |L1.34|
000022  e8bd4070          POP      {r4-r6,lr}
000026  2002              MOVS     r0,#2
000028  f7ffbffe          B.W      ModbusErr
                  |L1.44|
;;;17       
;;;18       //Адрес первого регистра * 32 слова
;;;19     	Addr	= ((RxBuff[2] << 8) | RxBuff[3]) << 5;	
00002c  884a              LDRH     r2,[r1,#2]
00002e  ba52              REV16    r2,r2
000030  0152              LSLS     r2,r2,#5
;;;20       if ((Addr + i) > (DataLen >> 1)) return ModbusErr(0x02, RxBuff, TxBuff);						
000032  1815              ADDS     r5,r2,r0
000034  ebb50f5c          CMP      r5,r12,LSR #1
000038  d905              BLS      |L1.70|
00003a  4622              MOV      r2,r4
00003c  e8bd4070          POP      {r4-r6,lr}
000040  2002              MOVS     r0,#2
000042  f7ffbffe          B.W      ModbusErr
                  |L1.70|
;;;21     		
;;;22     	DataAddr += Addr;																/* Начальный адрес считываемых данных */
;;;23     
;;;24     	((uint16_t *)TxBuff)[0] = ((uint16_t *)RxBuff)[0];
000046  8809              LDRH     r1,[r1,#0]
000048  8021              STRH     r1,[r4,#0]
;;;25     
;;;26     	TxBuff[2] = (i << 1);														/* Кол-во байт данных */
00004a  0041              LSLS     r1,r0,#1
00004c  eb030342          ADD      r3,r3,r2,LSL #1       ;22
;;;27     					j = 3;
000050  f04f0c03          MOV      r12,#3
000054  70a1              STRB     r1,[r4,#2]            ;26
;;;28     					k = 3 + (i << 1);												/**/
000056  eb0c0540          ADD      r5,r12,r0,LSL #1
;;;29     
;;;30     	/* Если начинается с нечетного адреса, то сначала считываем полуслово и таким образом выравниваем адрес на границу слова		*/
;;;31     	if ((uint32_t)DataAddr & 0x02) {
00005a  f0130f02          TST      r3,#2
00005e  d006              BEQ      |L1.110|
;;;32     		Data = (DataAddr++)[0]; 
000060  f8330b02          LDRH     r0,[r3],#2
;;;33     		TxBuff[j++] = Data>>8;
;;;34     		TxBuff[j++] = Data;
000064  f04f0c05          MOV      r12,#5
000068  0a01              LSRS     r1,r0,#8              ;33
00006a  70e1              STRB     r1,[r4,#3]            ;33
00006c  7120              STRB     r0,[r4,#4]
                  |L1.110|
;;;35     	}
;;;36     
;;;37     	/* Далее считываем целиком словами 																																													*/
;;;38     	for ( ; j<k ; )	{
00006e  45ac              CMP      r12,r5
000070  da08              BGE      |L1.132|
                  |L1.114|
;;;39     		Data = *((uint32_t *)DataAddr++);					/* Считываем сразу слово = два полуслова		*/
000072  f8530b04          LDR      r0,[r3],#4
;;;40     		DataAddr++;		
;;;41     		((uint32_t *)(&TxBuff[j]))[0] = ((Data & 0xFF00FF00) >> 8) | ((Data & 0x00FF00FF) << 8);
000076  ba40              REV16    r0,r0
000078  f844000c          STR      r0,[r4,r12]
00007c  f10c0c04          ADD      r12,r12,#4
000080  45ac              CMP      r12,r5                ;38
000082  dbf6              BLT      |L1.114|
                  |L1.132|
;;;42     		j += 4;
;;;43     	} 
;;;44     
;;;45     	Data = CalcCRC(k, TxBuff);
000084  4621              MOV      r1,r4
000086  4628              MOV      r0,r5
000088  f7fffffe          BL       CalcCRC
00008c  4601              MOV      r1,r0
;;;46     	TxBuff[k++] = Data;
00008e  5560              STRB     r0,[r4,r5]
000090  1c68              ADDS     r0,r5,#1
;;;47     	TxBuff[k++]	= Data>>8;
000092  0a09              LSRS     r1,r1,#8
000094  5421              STRB     r1,[r4,r0]
000096  1ca8              ADDS     r0,r5,#2
;;;48     
;;;49     	return k;
;;;50     }
000098  bd70              POP      {r4-r6,pc}
;;;51     
                          ENDP

                  ModbusStdProc PROC
;;;52     int ModbusStdProc(int RxCount, unsigned char *RxBuffer, unsigned char *TxBuffer, int Status, int PortNum) {
00009a  b5f8              PUSH     {r3-r7,lr}
00009c  4616              MOV      r6,r2
00009e  9f06              LDR      r7,[sp,#0x18]
0000a0  460c              MOV      r4,r1
0000a2  4605              MOV      r5,r0
;;;53     union UsartPrms_union Prms;
;;;54     	
;;;55     	if (Status & USART_RecieveError) return 0;				/* Ошибка четности или кол-во принятых данных	*/
0000a4  f0130f29          TST      r3,#0x29
0000a8  d10d              BNE      |L1.198|
;;;56     	if (RxCount < 4) return 0;																							/* Слишком мало байт принято									*/
0000aa  2d04              CMP      r5,#4
0000ac  db0b              BLT      |L1.198|
;;;57     	if (CalcCRC(RxCount, RxBuffer)) return 0;																/* Ошибка CRC																	*/
0000ae  4628              MOV      r0,r5
0000b0  f7fffffe          BL       CalcCRC
0000b4  b938              CBNZ     r0,|L1.198|
;;;58     																																					/* Проверка адреса Slave											*/
;;;59     	Prms.AllParams = GetSavedUartParams(PortNum);
0000b6  4638              MOV      r0,r7
0000b8  f7fffffe          BL       GetSavedUartParams
;;;60     	if (Prms.Params.Addr1 != RxBuffer[0]) {return 0;}
0000bc  7821              LDRB     r1,[r4,#0]
0000be  f3c04007          UBFX     r0,r0,#16,#8          ;59
0000c2  4288              CMP      r0,r1
0000c4  d001              BEQ      |L1.202|
                  |L1.198|
0000c6  2000              MOVS     r0,#0
;;;61     
;;;62     	switch (RxBuffer[1]) {
;;;63     	  case 0x03: return Modbus03(RxCount, RxBuffer, TxBuffer, (unsigned short *)&PrgData, sizeof(PrgData)); break;
;;;64     		case 0x04: return Modbus04ExtMem(RxCount, RxBuffer, TxBuffer, (uint16_t *)&ExtMem16[0], sizeof(ExtMem16)); break;
;;;65     		case 0x06: return Modbus06(RxCount, RxBuffer, TxBuffer, (unsigned short *)&PrgData, sizeof(PrgData)); break;
;;;66     		case 0x08: return Modbus08(RxCount, RxBuffer, TxBuffer, (unsigned short *)&PrgData, sizeof(PrgData)); break;
;;;67     		case 0x10: return Modbus16(RxCount, RxBuffer, TxBuffer, (unsigned short *)&PrgData, sizeof(PrgData)); break;
;;;68     		default:	 return ModbusErr(0x01, RxBuffer, TxBuffer);
;;;69     		}
;;;70     }
0000c8  bdf8              POP      {r3-r7,pc}
                  |L1.202|
0000ca  7860              LDRB     r0,[r4,#1]            ;62
0000cc  f6420114          MOV      r1,#0x2814            ;63
0000d0  2806              CMP      r0,#6                 ;62
0000d2  d028              BEQ      |L1.294|
0000d4  dc04              BGT      |L1.224|
0000d6  2803              CMP      r0,#3                 ;62
0000d8  d00d              BEQ      |L1.246|
0000da  2804              CMP      r0,#4                 ;62
0000dc  d016              BEQ      |L1.268|
0000de  e003              B        |L1.232|
                  |L1.224|
0000e0  2808              CMP      r0,#8                 ;62
0000e2  d02b              BEQ      |L1.316|
0000e4  2810              CMP      r0,#0x10              ;62
0000e6  d034              BEQ      |L1.338|
                  |L1.232|
0000e8  4632              MOV      r2,r6                 ;68
0000ea  4621              MOV      r1,r4                 ;68
0000ec  e8bd40f8          POP      {r3-r7,lr}            ;68
0000f0  2001              MOVS     r0,#1                 ;68
0000f2  f7ffbffe          B.W      ModbusErr
                  |L1.246|
0000f6  f2400300          MOVW     r3,#:LOWER16: Metro
0000fa  f2c00300          MOVT     r3,#:UPPER16: Metro
0000fe  9100              STR      r1,[sp,#0]            ;63
000100  4632              MOV      r2,r6                 ;63
000102  4621              MOV      r1,r4                 ;63
000104  4628              MOV      r0,r5                 ;63
000106  f7fffffe          BL       Modbus03
00010a  bdf8              POP      {r3-r7,pc}
                  |L1.268|
00010c  f44f1000          MOV      r0,#0x200000          ;64
000110  f2400300          MOVW     r3,#:LOWER16: ExtMem
000114  f2c00300          MOVT     r3,#:UPPER16: ExtMem
000118  9000              STR      r0,[sp,#0]            ;64
00011a  4632              MOV      r2,r6                 ;64
00011c  4621              MOV      r1,r4                 ;64
00011e  4628              MOV      r0,r5                 ;64
000120  f7fffffe          BL       Modbus04ExtMem
000124  bdf8              POP      {r3-r7,pc}
                  |L1.294|
000126  f2400300          MOVW     r3,#:LOWER16: Metro
00012a  f2c00300          MOVT     r3,#:UPPER16: Metro
00012e  9100              STR      r1,[sp,#0]            ;65
000130  4632              MOV      r2,r6                 ;65
000132  4621              MOV      r1,r4                 ;65
000134  4628              MOV      r0,r5                 ;65
000136  f7fffffe          BL       Modbus06
00013a  bdf8              POP      {r3-r7,pc}
                  |L1.316|
00013c  f2400300          MOVW     r3,#:LOWER16: Metro
000140  f2c00300          MOVT     r3,#:UPPER16: Metro
000144  9100              STR      r1,[sp,#0]            ;66
000146  4632              MOV      r2,r6                 ;66
000148  4621              MOV      r1,r4                 ;66
00014a  4628              MOV      r0,r5                 ;66
00014c  f7fffffe          BL       Modbus08
000150  bdf8              POP      {r3-r7,pc}
                  |L1.338|
000152  f2400300          MOVW     r3,#:LOWER16: Metro
000156  f2c00300          MOVT     r3,#:UPPER16: Metro
00015a  9100              STR      r1,[sp,#0]            ;67
00015c  4632              MOV      r2,r6                 ;67
00015e  4621              MOV      r1,r4                 ;67
000160  4628              MOV      r0,r5                 ;67
000162  f7fffffe          BL       Modbus16
000166  bdf8              POP      {r3-r7,pc}
;;;71     
                          ENDP

                  RecieveTemprData PROC
;;;72     int RecieveTemprData(int RxCount, unsigned char *RxBuffer, unsigned char *TxBuffer, int Status, int PortNum) {
000168  b510              PUSH     {r4,lr}
00016a  460c              MOV      r4,r1
;;;73     union UsartPrms_union Prms;
;;;74     int i;
;;;75     	
;;;76     	if (Status & USART_RecieveError) return 0;															/* Ошибка четности или кол-во принятых данных	*/
00016c  f0130f29          TST      r3,#0x29
;;;77     	if (RxCount != 26) return 0;																						/* Слишком мало байт принято									*/
000170  bf08              IT       EQ
000172  281a              CMPEQ    r0,#0x1a
000174  d110              BNE      |L1.408|
;;;78     	if (CalcCRC(RxCount, RxBuffer)) return 0;																/* Ошибка CRC																	*/
000176  4621              MOV      r1,r4
000178  f7fffffe          BL       CalcCRC
00017c  2800              CMP      r0,#0
;;;79     																																					/* Проверка адреса Slave											*/
;;;80     	for (i = 0; i < 24; i++) {EvPrms.T[i] = RxBuffer[i];}
00017e  bf04              ITT      EQ
000180  f2400200          MOVWEQ   r2,#:LOWER16: Metro
000184  f2c00200          MOVTEQ   r2,#:UPPER16: Metro
000188  d106              BNE      |L1.408|
                  |L1.394|
00018a  5c21              LDRB     r1,[r4,r0]
00018c  1813              ADDS     r3,r2,r0
00018e  1c40              ADDS     r0,r0,#1
000190  f8831050          STRB     r1,[r3,#0x50]
000194  2818              CMP      r0,#0x18
000196  dbf8              BLT      |L1.394|
                  |L1.408|
;;;81     
;;;82     	return 0;
000198  2000              MOVS     r0,#0
;;;83     }	//int RecieveCellData(int RxCount, unsigned char *RxBuffer, unsigned char *TxBuffer, int Status, int PortNum)
00019a  bd10              POP      {r4,pc}
;;;84     
                          ENDP

                  RecieveSlaveData PROC
;;;85     int RecieveSlaveData(int RxCount, unsigned char *RxBuffer, unsigned char *TxBuffer, int Status, int PortNum) {
00019c  b510              PUSH     {r4,lr}
00019e  460c              MOV      r4,r1
;;;86     union UsartPrms_union Prms;
;;;87     short *SendDataPtr;
;;;88     int i;
;;;89     	
;;;90     	if (Status & USART_RecieveError) return 0;															/* Ошибка четности или кол-во принятых данных	*/
0001a0  f0130f29          TST      r3,#0x29
;;;91     	if (RxCount != 62) return 0;																						/* Слишком мало байт принято									*/
0001a4  bf08              IT       EQ
0001a6  283e              CMPEQ    r0,#0x3e
0001a8  d131              BNE      |L1.526|
;;;92     	if (CalcCRC(RxCount, RxBuffer)) return 0;																/* Ошибка CRC																	*/
0001aa  4621              MOV      r1,r4
0001ac  f7fffffe          BL       CalcCRC
0001b0  bb68              CBNZ     r0,|L1.526|
;;;93     																																					/* Проверка адреса Slave											*/
;;;94     	SendDataPtr = &EvPrms.I1Flt2;
0001b2  f2400300          MOVW     r3,#:LOWER16: Metro
0001b6  f2c00300          MOVT     r3,#:UPPER16: Metro
0001ba  f10301b6          ADD      r1,r3,#0xb6
;;;95     	for (i = 0; i < 12; i++) *SendDataPtr++ = ((short *)RxBuffer)[i];
0001be  2000              MOVS     r0,#0
                  |L1.448|
0001c0  f8342010          LDRH     r2,[r4,r0,LSL #1]
0001c4  1c40              ADDS     r0,r0,#1
0001c6  f8212b02          STRH     r2,[r1],#2
0001ca  280c              CMP      r0,#0xc
0001cc  dbf8              BLT      |L1.448|
;;;96     
;;;97     	SendDataPtr = EvPrms.TD;
0001ce  f1030068          ADD      r0,r3,#0x68
;;;98     	for (i = 12; i < 16; i++) *SendDataPtr++ = ((short *)RxBuffer)[i];
0001d2  220c              MOVS     r2,#0xc
                  |L1.468|
0001d4  f8341012          LDRH     r1,[r4,r2,LSL #1]
0001d8  1c52              ADDS     r2,r2,#1
0001da  f8201b02          STRH     r1,[r0],#2
0001de  2a10              CMP      r2,#0x10
0001e0  dbf8              BLT      |L1.468|
;;;99     	for (i = 16; i < 18; i++) *SendDataPtr++ = __USAT((((short *)RxBuffer)[i] - 800), 16);
0001e2  2210              MOVS     r2,#0x10
                  |L1.484|
0001e4  f9341012          LDRSH    r1,[r4,r2,LSL #1]
0001e8  1c52              ADDS     r2,r2,#1
0001ea  f5a17148          SUB      r1,r1,#0x320
0001ee  f3810110          USAT     r1,#16,r1
0001f2  f8201b02          STRH     r1,[r0],#2
0001f6  2a12              CMP      r2,#0x12
0001f8  dbf4              BLT      |L1.484|
;;;100    
;;;101    	SendDataPtr = (short *)EvPrms.T;
0001fa  f1030150          ADD      r1,r3,#0x50
;;;102    	for (i = 18; i < 30; i++) *SendDataPtr++ = ((short *)RxBuffer)[i];
0001fe  2012              MOVS     r0,#0x12
                  |L1.512|
000200  f8342010          LDRH     r2,[r4,r0,LSL #1]
000204  1c40              ADDS     r0,r0,#1
000206  f8212b02          STRH     r2,[r1],#2
00020a  281e              CMP      r0,#0x1e
00020c  dbf8              BLT      |L1.512|
                  |L1.526|
;;;103    
;;;104    	return 0;
00020e  2000              MOVS     r0,#0
;;;105    }	//int RecieveCellData(int RxCount, unsigned char *RxBuffer, unsigned char *TxBuffer, int Status, int PortNum) 
000210  bd10              POP      {r4,pc}
;;;106    
                          ENDP

                  RecieveDriverData PROC
;;;107    int RecieveDriverData(int RxCount, unsigned char *RxBuffer, unsigned char *TxBuffer, int Status, int PortNum) {
000212  b570              PUSH     {r4-r6,lr}
000214  460c              MOV      r4,r1
;;;108    short *SendDataPtr;
;;;109    int i;
;;;110    	
;;;111    	if (Status & USART_RecieveError) return 0;															/* Ошибка четности или кол-во принятых данных	*/
000216  9d04              LDR      r5,[sp,#0x10]
000218  f0130f29          TST      r3,#0x29
;;;112    	if (RxCount != 18) return 0;																						/* Слишком мало байт принято									*/
00021c  bf08              IT       EQ
00021e  2812              CMPEQ    r0,#0x12
000220  d119              BNE      |L1.598|
;;;113    	if (CalcCRC(RxCount, RxBuffer)) return 0;																/* Ошибка CRC																	*/
000222  4621              MOV      r1,r4
000224  f7fffffe          BL       CalcCRC
000228  b9a8              CBNZ     r0,|L1.598|
;;;114    	
;;;115    	if (PortNum == X14_15) {
;;;116    		if (RxBuffer[0] == 0x01) {SendDataPtr = EvPrms.IGBTStat3;} else {SendDataPtr = EvPrms.IGBTStat1;} 
00022a  f2400000          MOVW     r0,#:LOWER16: Metro
00022e  f2c00000          MOVT     r0,#:UPPER16: Metro
000232  2d01              CMP      r5,#1                 ;115
000234  d002              BEQ      |L1.572|
;;;117    	} else if (PortNum == X16_17) {
000236  2d02              CMP      r5,#2
000238  d00f              BEQ      |L1.602|
00023a  e00c              B        |L1.598|
                  |L1.572|
00023c  7821              LDRB     r1,[r4,#0]            ;116
00023e  2901              CMP      r1,#1                 ;116
000240  bf14              ITE      NE                    ;116
000242  308c              ADDNE    r0,r0,#0x8c           ;116
000244  30a8              ADDEQ    r0,r0,#0xa8           ;116
                  |L1.582|
;;;118    		if (RxBuffer[0] == 0x01) {SendDataPtr = EvPrms.IGBTStat4;} else {SendDataPtr = EvPrms.IGBTStat2;} 
;;;119    	} else return 0;
;;;120    	
;;;121    	for (i = 1; i < 8; i++) *SendDataPtr++ = ((short *)RxBuffer)[i];
000246  2201              MOVS     r2,#1
                  |L1.584|
000248  f8341012          LDRH     r1,[r4,r2,LSL #1]
00024c  1c52              ADDS     r2,r2,#1
00024e  f8201b02          STRH     r1,[r0],#2
000252  2a08              CMP      r2,#8
000254  dbf8              BLT      |L1.584|
                  |L1.598|
;;;122    	
;;;123    	return 0;
000256  2000              MOVS     r0,#0
;;;124    }	//int RecieveCellData(int RxCount, unsigned char *RxBuffer, unsigned char *TxBuffer, int Status, int PortNum) 
000258  bd70              POP      {r4-r6,pc}
                  |L1.602|
00025a  7821              LDRB     r1,[r4,#0]            ;118
00025c  2901              CMP      r1,#1                 ;118
00025e  bf14              ITE      NE                    ;118
000260  309a              ADDNE    r0,r0,#0x9a           ;118
000262  30e6              ADDEQ    r0,r0,#0xe6           ;118
000264  e7ef              B        |L1.582|
                          ENDP


;*** Start embedded assembler ***

#line 1 "SOURCE\\Protocol.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_Protocol_c_0c9971f6____REV16|
#line 129 ".\\STARTUP\\core_cmInstr.h"
|__asm___10_Protocol_c_0c9971f6____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_Protocol_c_0c9971f6____REVSH|
#line 144
|__asm___10_Protocol_c_0c9971f6____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
