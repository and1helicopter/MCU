; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--c99 --no_integer_literal_pools --list -c --asm --interleave -o.\exec\rtc.o --asm_dir=.\LIST\ --list_dir=.\LIST\ --depend=.\exec\rtc.d --cpu=Cortex-M4.fp --apcs=interwork -Otime --diag_suppress=9931 -I.\STARTUP -I.\PERIPH -I..\PRG1 -I.\SOURCE -IF:\Program\Keil_v5\ARM\RV31\INC -IF:\Program\Keil_v5\ARM\CMSIS\Include -IF:\Program\Keil_v5\ARM\INC\ST\STM32F4xx -D__UVISION_VERSION=524 -DEK_PP_0815_12_03 -DSTM32F429_439xx --omf_browse=.\exec\rtc.crf PERIPH\rtc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  SetRTC PROC
;;;107    
;;;108    void SetRTC(uint32_t Date, uint32_t Time) {
000000  f6430270          MOV      r2,#0x3870
;;;109    #if (RTC_Present == YES)
;;;110      if (RCC->BDCR != 0x8103) return;																						/* Выходим, если нет Clock-ов						*/
000004  f2c40202          MOVT     r2,#0x4002
000008  6812              LDR      r2,[r2,#0]
00000a  f5a24301          SUB      r3,r2,#0x8100
00000e  3b03              SUBS     r3,#3
;;;111    	
;;;112    	/* Init clock / calendar										*/
;;;113    	PWR->CR  |= PWR_CR_DBP;																											/* Disable clock - calendar protection	*/																										
;;;114    	RTC->WPR 	= 0xCA;																													
;;;115    	RTC->WPR 	= 0x53;
;;;116    	RTC->ISR |= RTC_ISR_INIT;
;;;117    
;;;118    	while ((RTC->ISR & RTC_ISR_INITF) == 0);																		/* wait for init mode		*/ 
;;;119        
;;;120    	RTC->DR		= Date;
;;;121    	RTC->TR 	= Time & 0x003F7F7F;
;;;122    
;;;123    	RTC->ISR &= ~RTC_ISR_INIT;
;;;124      
;;;125    //  RTC->SHIFTR = 0xFF - (((500 * 256) / 1000) & 0xFF) ;
;;;126      
;;;127    	RTC->WPR 	= 0x00;
;;;128    #endif	
;;;129    }
000010  bf18              IT       NE
000012  4770              BXNE     lr
000014  f44f42e0          MOV      r2,#0x7000            ;113
000018  f2c40200          MOVT     r2,#0x4000            ;113
00001c  6813              LDR      r3,[r2,#0]            ;113
00001e  f4437380          ORR      r3,r3,#0x100          ;113
000022  6013              STR      r3,[r2,#0]            ;113
000024  f6420c24          MOV      r12,#0x2824           ;114
000028  f2c40c00          MOVT     r12,#0x4000           ;114
00002c  22ca              MOVS     r2,#0xca              ;114
00002e  f8cc2000          STR      r2,[r12,#0]           ;114
000032  2253              MOVS     r2,#0x53              ;115
000034  f8cc2000          STR      r2,[r12,#0]           ;115
000038  f642020c          MOV      r2,#0x280c            ;116
00003c  f2c40200          MOVT     r2,#0x4000            ;116
000040  6813              LDR      r3,[r2,#0]            ;116
000042  f0430380          ORR      r3,r3,#0x80           ;116
000046  6013              STR      r3,[r2,#0]            ;116
                  |L1.72|
000048  6813              LDR      r3,[r2,#0]            ;118
00004a  f0130f40          TST      r3,#0x40              ;118
00004e  d0fb              BEQ      |L1.72|
000050  f6420304          MOV      r3,#0x2804            ;120
000054  f2c40300          MOVT     r3,#0x4000            ;120
000058  6018              STR      r0,[r3,#0]            ;120
00005a  f647707f          MOV      r0,#0x7f7f            ;121
00005e  f2c0003f          MOVT     r0,#0x3f              ;121
000062  4001              ANDS     r1,r1,r0              ;121
000064  1f18              SUBS     r0,r3,#4              ;121
000066  6001              STR      r1,[r0,#0]            ;121
000068  6810              LDR      r0,[r2,#0]            ;123
00006a  f0200080          BIC      r0,r0,#0x80           ;123
00006e  6010              STR      r0,[r2,#0]            ;123
000070  2000              MOVS     r0,#0                 ;127
000072  f8cc0000          STR      r0,[r12,#0]           ;127
000076  4770              BX       lr
;;;130    
                          ENDP

                  PackRTC PROC
;;;131    
;;;132    void PackRTC(uint32_t S_M_H, uint32_t D_M_Y) {
000078  b570              PUSH     {r4-r6,lr}
00007a  b083              SUB      sp,sp,#0xc
00007c  460b              MOV      r3,r1
;;;133    #if (RTC_Present == YES)	
;;;134    int32_t  i,Y,M,D,DW;
;;;135    int8_t DayInMonth[12] = {31,29,31,30,31,30,31,31,30,31,30,31};
00007e  f20f2cfc          ADR      r12,|L1.892|
000082  f8dc2004          LDR      r2,[r12,#4]
000086  f8dc1000          LDR      r1,[r12,#0]
00008a  f8dcc008          LDR      r12,[r12,#8]
00008e  e9cd1200          STRD     r1,r2,[sp,#0]
;;;136    	
;;;137    	/*Проверка данных - время	-----------------------------------------------	*/ 
;;;138    	if ((S_M_H & 0x0F) > 0x09) S_M_H = ((S_M_H & ~0x0F) | 0x09);
000092  f000010f          AND      r1,r0,#0xf
000096  f8cdc008          STR      r12,[sp,#8]           ;135
00009a  2909              CMP      r1,#9
00009c  bf84              ITT      HI
00009e  f020000f          BICHI    r0,r0,#0xf
0000a2  f0400009          ORRHI    r0,r0,#9
;;;139    	if ((S_M_H & 0xF0) > 0x50) S_M_H = ((S_M_H & ~0xF0) | 0x50);
0000a6  f00001f0          AND      r1,r0,#0xf0
0000aa  2950              CMP      r1,#0x50
0000ac  bf84              ITT      HI
0000ae  f02000f0          BICHI    r0,r0,#0xf0
0000b2  f0400050          ORRHI    r0,r0,#0x50
;;;140    
;;;141    	if ((S_M_H & 0x0F00) > 0x0900) S_M_H = ((S_M_H & ~0x0F00) | 0x0900);
0000b6  f4006170          AND      r1,r0,#0xf00
0000ba  f5b16f10          CMP      r1,#0x900
0000be  bf84              ITT      HI
0000c0  f4206070          BICHI    r0,r0,#0xf00
0000c4  f4406010          ORRHI    r0,r0,#0x900
;;;142    	if ((S_M_H & 0xF000) > 0x5000) S_M_H = ((S_M_H & ~0xF000) | 0x5000);
0000c8  f4004170          AND      r1,r0,#0xf000
0000cc  f5b14fa0          CMP      r1,#0x5000
0000d0  bf84              ITT      HI
0000d2  f4204070          BICHI    r0,r0,#0xf000
0000d6  f44040a0          ORRHI    r0,r0,#0x5000
;;;143    
;;;144    	if ((S_M_H & 0x0F0000) > 0x090000) S_M_H = ((S_M_H & ~0x0F0000) | 0x090000);
0000da  f4002170          AND      r1,r0,#0xf0000
0000de  f5b12f10          CMP      r1,#0x90000
0000e2  bf84              ITT      HI
0000e4  f4202070          BICHI    r0,r0,#0xf0000
0000e8  f4402010          ORRHI    r0,r0,#0x90000
;;;145    	if ((S_M_H & 0x300000) > 0x200000) S_M_H = ((S_M_H & ~0x300000) | 0x200000);
0000ec  f4001140          AND      r1,r0,#0x300000
0000f0  f5b11f00          CMP      r1,#0x200000
0000f4  bf84              ITT      HI
0000f6  f4201040          BICHI    r0,r0,#0x300000
0000fa  f4401000          ORRHI    r0,r0,#0x200000
;;;146    	if ((S_M_H & 0x3F0000) > 0x230000) S_M_H = ((S_M_H & ~0x3F0000) | 0x230000);
0000fe  f400117c          AND      r1,r0,#0x3f0000
000102  f5b11f0c          CMP      r1,#0x230000
000106  bf84              ITT      HI
000108  f420107c          BICHI    r0,r0,#0x3f0000
00010c  f440100c          ORRHI    r0,r0,#0x230000
;;;147    	
;;;148    //S_M_H	&= 0x003F7F7F;
;;;149    	
;;;150    	/*проверка данных - дата ------------------------------------------------	*/
;;;151    	Y = ((D_M_Y & 0x0F0000) >> 16) + ((D_M_Y & 0xF00000) >> 20) * 10;
000110  f3c35103          UBFX     r1,r3,#20,#4
000114  eb010181          ADD      r1,r1,r1,LSL #2
000118  f3c34203          UBFX     r2,r3,#16,#4
00011c  eb020241          ADD      r2,r2,r1,LSL #1
;;;152    	if (Y<15) Y = 15; 
000120  2a0f              CMP      r2,#0xf
000122  bfb8              IT       LT
000124  220f              MOVLT    r2,#0xf
000126  db02              BLT      |L1.302|
;;;153    	if (Y>99) Y = 99;
000128  2a63              CMP      r2,#0x63
00012a  bfc8              IT       GT
00012c  2263              MOVGT    r2,#0x63
                  |L1.302|
;;;154    
;;;155    	/*Проверка на високосный год - если не делится на 4, то в феврале 28	дней*/
;;;156    	if (Y&0x3) DayInMonth[1] = 28;
00012e  f0120f03          TST      r2,#3
000132  bf1c              ITT      NE
000134  211c              MOVNE    r1,#0x1c
000136  f88d1001          STRBNE   r1,[sp,#1]
;;;157    
;;;158    	M = ((D_M_Y & 0x0F00) >> 8) + ((D_M_Y & 0x1000) >> 12) * 10;
00013a  f3c33100          UBFX     r1,r3,#12,#1
00013e  eb010181          ADD      r1,r1,r1,LSL #2
000142  f3c32c03          UBFX     r12,r3,#8,#4
000146  eb0c0141          ADD      r1,r12,r1,LSL #1
;;;159    	if (M<1) 	M = 1;
00014a  2901              CMP      r1,#1
00014c  bfb8              IT       LT
00014e  2101              MOVLT    r1,#1
000150  db02              BLT      |L1.344|
;;;160    	if (M>12) M = 12;
000152  290c              CMP      r1,#0xc
000154  bfc8              IT       GT
000156  210c              MOVGT    r1,#0xc
                  |L1.344|
;;;161    
;;;162    	D = (D_M_Y & 0x0F) + ((D_M_Y & 0x30) >> 4) * 10;
000158  f0030c0f          AND      r12,r3,#0xf
00015c  f3c31301          UBFX     r3,r3,#4,#2
000160  eb030383          ADD      r3,r3,r3,LSL #2
000164  eb0c0c43          ADD      r12,r12,r3,LSL #1
;;;163    	if (D<1) 	D = 1;
000168  f1bc0f01          CMP      r12,#1
00016c  bfb8              IT       LT
00016e  f04f0c01          MOVLT    r12,#1
;;;164    	if (D>DayInMonth[M-1]) D = DayInMonth[M-1]; 
000172  466d              MOV      r5,sp
000174  eb0d0301          ADD      r3,sp,r1
000178  f9133c01          LDRSB    r3,[r3,#-1]
00017c  4563              CMP      r3,r12
00017e  bfb8              IT       LT
000180  469c              MOVLT    r12,r3
;;;165    
;;;166    	/* Определение дня недели */
;;;167    	DW = (Y-12)*365 + (Y-13)/4;														/*Кол-во дней c 01 января 2012 до 01 января года Y*/
000182  f1a2030d          SUB      r3,r2,#0xd
000186  1c5c              ADDS     r4,r3,#1
000188  f240166d          MOV      r6,#0x16d
00018c  fb14f406          SMULBB   r4,r4,r6
000190  17de              ASRS     r6,r3,#31
000192  eb037396          ADD      r3,r3,r6,LSR #30
000196  eb0404a3          ADD      r4,r4,r3,ASR #2
;;;168    	for (i = 1; i < M; i++) DW += DayInMonth[i-1];				/*Кол-во дней полных месяцев											*/ 
00019a  2301              MOVS     r3,#1
00019c  2901              CMP      r1,#1
00019e  dd06              BLE      |L1.430|
                  |L1.416|
0001a0  18ee              ADDS     r6,r5,r3
0001a2  1c5b              ADDS     r3,r3,#1
0001a4  f9166c01          LDRSB    r6,[r6,#-1]
0001a8  4299              CMP      r1,r3
0001aa  4434              ADD      r4,r4,r6
0001ac  dcf8              BGT      |L1.416|
                  |L1.430|
;;;169    	DW += D;																							/*Текущий день																		*/
0001ae  4464              ADD      r4,r4,r12
;;;170    	DW %= 7;																							/*Остаток от целых недель													*/
0001b0  f2424693          MOV      r6,#0x2493
0001b4  4623              MOV      r3,r4
0001b6  f2c92649          MOVT     r6,#0x9249
0001ba  2500              MOVS     r5,#0
0001bc  fbc65304          SMLAL    r5,r3,r6,r4
0001c0  109d              ASRS     r5,r3,#2
0001c2  eba573e3          SUB      r3,r5,r3,ASR #31
0001c6  eba303c3          SUB      r3,r3,r3,LSL #3
0001ca  191b              ADDS     r3,r3,r4
;;;171    	if (DW == 0) DW = 7;																	/**/
0001cc  bf08              IT       EQ
0001ce  2307              MOVEQ    r3,#7
;;;172    	
;;;173    	D_M_Y = (D%10) + ((D/10)<<4) + ((M%10)<<8) + ((M/10)<<12) + ((Y%10)<<16) + ((Y/10)<<20) + (DW << 13);
0001d0  f2466667          MOV      r6,#0x6667
0001d4  f2c66666          MOVT     r6,#0x6666
0001d8  fb86540c          SMULL    r5,r4,r6,r12
0001dc  10a5              ASRS     r5,r4,#2
0001de  eba574e4          SUB      r4,r5,r4,ASR #31
0001e2  4265              RSBS     r5,r4,#0
0001e4  eb050585          ADD      r5,r5,r5,LSL #2
0001e8  eb0c0c45          ADD      r12,r12,r5,LSL #1
0001ec  eb0c1504          ADD      r5,r12,r4,LSL #4
0001f0  fb864c01          SMULL    r4,r12,r6,r1
0001f4  ea4f04ac          ASR      r4,r12,#2
0001f8  eba47cec          SUB      r12,r4,r12,ASR #31
0001fc  f1cc0400          RSB      r4,r12,#0
000200  eb040484          ADD      r4,r4,r4,LSL #2
000204  eb010144          ADD      r1,r1,r4,LSL #1
000208  eb052101          ADD      r1,r5,r1,LSL #8
00020c  eb01340c          ADD      r4,r1,r12,LSL #12
000210  fb86c102          SMULL    r12,r1,r6,r2
000214  ea4f0ca1          ASR      r12,r1,#2
000218  ebac71e1          SUB      r1,r12,r1,ASR #31
00021c  f1c10c00          RSB      r12,r1,#0
000220  eb0c0c8c          ADD      r12,r12,r12,LSL #2
000224  eb02024c          ADD      r2,r2,r12,LSL #1
000228  eb044202          ADD      r2,r4,r2,LSL #16
00022c  eb025101          ADD      r1,r2,r1,LSL #20
000230  eb013243          ADD      r2,r1,r3,LSL #13
;;;174    
;;;175      SetRTC(D_M_Y, S_M_H);
000234  4601              MOV      r1,r0
000236  4610              MOV      r0,r2
000238  f7fffffe          BL       SetRTC
;;;176    #endif	
;;;177    }
00023c  b003              ADD      sp,sp,#0xc
00023e  bd70              POP      {r4-r6,pc}
;;;178    
                          ENDP

                  InitRTC PROC
;;;5      
;;;6      int32_t InitRTC(uint32_t Timeout) {
000240  f6430170          MOV      r1,#0x3870
000244  b500              PUSH     {lr}
;;;7      #if (RTC_Present == YES)
;;;8      int  TempDate;
;;;9      int  TempTime;
;;;10     
;;;11     	/* Check for RTC clock	*/
;;;12     	if (RCC->BDCR != 0x8103) 																									  /* Check RTC clock											*/
000246  f2c40102          MOVT     r1,#0x4002
00024a  680a              LDR      r2,[r1,#0]
00024c  f2481303          MOV      r3,#0x8103
000250  429a              CMP      r2,r3
000252  d026              BEQ      |L1.674|
;;;13       {
;;;14     		PWR->CR |= PWR_CR_DBP;																										/* Disable write protect for RCC->BDCR	*/
000254  f44f42e0          MOV      r2,#0x7000
000258  f2c40200          MOVT     r2,#0x4000
00025c  f8d2c000          LDR      r12,[r2,#0]
000260  f44c7c80          ORR      r12,r12,#0x100
000264  f8c2c000          STR      r12,[r2,#0]
;;;15     		
;;;16     		if (RCC->BDCR & 0x0204) 																									/* LSI or HSE as RTC clock or LSE bypass*/
000268  680a              LDR      r2,[r1,#0]
00026a  f4127f01          TST      r2,#0x204
00026e  d007              BEQ      |L1.640|
;;;17         {
;;;18     			RCC->BDCR |= RCC_BDCR_BDRST;																						/* Reset BDCR to 00											*/
000270  680a              LDR      r2,[r1,#0]
000272  f4423280          ORR      r2,r2,#0x10000
000276  600a              STR      r2,[r1,#0]
                  |L1.632|
;;;19     			while (RCC->BDCR & 0x0304);																							/* Wait for clear bit										*/
000278  680a              LDR      r2,[r1,#0]
00027a  f4127f41          TST      r2,#0x304
00027e  d1fb              BNE      |L1.632|
                  |L1.640|
;;;20         }	//if (RCC->BDCR & 0x0204)
;;;21     				
;;;22     		RCC->BDCR &=~RCC_BDCR_BDRST;																							/* Clear RESET bit											*/
000280  680a              LDR      r2,[r1,#0]
000282  f4223280          BIC      r2,r2,#0x10000
000286  600a              STR      r2,[r1,#0]
;;;23     		RCC->BDCR |= RCC_BDCR_LSEON;																							/* Enable LSE clock											*/
000288  680a              LDR      r2,[r1,#0]
00028a  f0420201          ORR      r2,r2,#1
00028e  600a              STR      r2,[r1,#0]
                  |L1.656|
;;;24     		while (((RCC->BDCR & RCC_BDCR_LSERDY) == 0) && (--Timeout));							/* Wait for LSE clock ready							*/
000290  680a              LDR      r2,[r1,#0]
000292  f0120f02          TST      r2,#2
000296  d009              BEQ      |L1.684|
;;;25     
;;;26     		if (Timeout == 0) return 0;				
000298  b130              CBZ      r0,|L1.680|
;;;27     	
;;;28     		RCC->BDCR	|= (RCC_BDCR_RTCSEL_LSE | RCC_BDCR_RTCEN);										/* Select LSE as RTC clock & Ena RTC 		*/
00029a  6808              LDR      r0,[r1,#0]
00029c  f4404001          ORR      r0,r0,#0x8100
0002a0  6008              STR      r0,[r1,#0]
                  |L1.674|
;;;29     	} //if ((RCC->BDCR & 0x8303) != 0x8103)	
;;;30     	
;;;31     	/* if Clock not OK - return									*/
;;;32     	if (RCC->BDCR != 0x8103) return 0;
0002a2  6808              LDR      r0,[r1,#0]
0002a4  4298              CMP      r0,r3
0002a6  d004              BEQ      |L1.690|
                  |L1.680|
0002a8  2000              MOVS     r0,#0
;;;33     	
;;;34     	/* Check clock / calendar for already init	*/
;;;35     	if (RTC->ISR & RTC_ISR_INITS) return 1;
;;;36       
;;;37       {	/* Расчет Даты / Время компиляции программы	*/
;;;38         TempTime = 	 (__TIME__[7] - 0x30) 			 | ((__TIME__[6] - 0x30) << 4) |
;;;39                     ((__TIME__[4] - 0x30) << 8)  | ((__TIME__[3] - 0x30) << 12)|
;;;40                     ((__TIME__[1] - 0x30) << 16) | ((__TIME__[0] - 0x30) << 20);
;;;41         
;;;42         TempDate = 	(__DATE__[5] - 0x30) | ((__DATE__[10] - 0x30) << 16) | ((__DATE__[9] - 0x30) << 20);
;;;43         if (__DATE__[4] != 0x20) TempDate |= ((__DATE__[4] - 0x30) << 4);
;;;44         
;;;45         switch (__DATE__[0]) 
;;;46         {
;;;47           case 0x4A:	{ if (__DATE__[1] == 0x61) TempDate |= 0x0100; else			/* Jan	*/	
;;;48                           if (__DATE__[2] == 0x6E) TempDate |= 0x0600; else		/* Jun 	*/	
;;;49                             TempDate |= 0x0700;																/* Jul	*/
;;;50                       } break;
;;;51           case 0x46:	TempDate |= 0x0200; break;															/* Feb	*/
;;;52           case 0x4D:	{	if (__DATE__[2] == 0x72) 	TempDate |= 0x0300; else		/* Mar 	*/	
;;;53                           TempDate |= 0x0500;																	/* May	*/
;;;54                       } break;
;;;55           case 0x41:	{	if (__DATE__[2] == 0x72) 	TempDate |= 0x0400; else		/* Apr 	*/	
;;;56                           TempDate |= 0x0800;																	/* Aug	*/
;;;57                       } break;
;;;58           case 0x53:	TempDate |= 0x0900; break;															/* Sep	*/
;;;59           case 0x4F:	TempDate |= 0x1000; break;															/* Oct	*/
;;;60           case 0x4E:	TempDate |= 0x1100; break;															/* Nov	*/
;;;61           case 0x44:	TempDate |= 0x1200; break;															/* Dec	*/
;;;62           default:		TempDate |= 0x0100; break;
;;;63         }	
;;;64       }
;;;65     	/* По умолчанию ставим дату/время компилирования программы										*/
;;;66     	PackRTC(TempTime, TempDate);
;;;67     	return 2;
;;;68     #else
;;;69     	return 0;
;;;70     #endif
;;;71     
;;;72     }
0002aa  bd00              POP      {pc}
                  |L1.684|
0002ac  1e40              SUBS     r0,r0,#1
0002ae  d1ef              BNE      |L1.656|
0002b0  e7fa              B        |L1.680|
                  |L1.690|
0002b2  f642000c          MOV      r0,#0x280c            ;35
0002b6  f2c40000          MOVT     r0,#0x4000            ;35
0002ba  6800              LDR      r0,[r0,#0]            ;35
0002bc  f0100f10          TST      r0,#0x10              ;35
0002c0  bf1c              ITT      NE                    ;35
0002c2  2001              MOVNE    r0,#1                 ;35
0002c4  bd00              POPNE    {pc}
0002c6  f2456007          MOV      r0,#0x5607            ;38
0002ca  f2405115          MOV      r1,#0x515             ;53
0002ce  f2c00009          MOVT     r0,#9                 ;38
0002d2  f2c00118          MOVT     r1,#0x18              ;53
0002d6  f7fffffe          BL       PackRTC
0002da  2002              MOVS     r0,#2                 ;67
0002dc  bd00              POP      {pc}
;;;73     
                          ENDP

                  ReadRTC PROC
;;;74     
;;;75     int32_t  ReadRTC(int32_t RtcWait, uint32_t *RtcDate, uint32_t *RtcTime) {
0002de  b470              PUSH     {r4-r6}
;;;76     #if (RTC_Present == YES)
;;;77     static uint32_t OldSS = ~0ul;
;;;78     static uint32_t ms = 0;
;;;79       
;;;80     uint32_t SS, T, D;  
;;;81     	if (!(RtcWait | (RTC->ISR & RTC_ISR_RSF))) return 0;				          /* Выходим, если бит часов не установлен и мы не ждем */
0002e0  f642030c          MOV      r3,#0x280c
0002e4  f2c40300          MOVT     r3,#0x4000
0002e8  f8d3c000          LDR      r12,[r3,#0]
0002ec  f00c0c20          AND      r12,r12,#0x20
0002f0  ea5c0000          ORRS     r0,r12,r0
;;;82       while ((RTC->ISR & RTC_ISR_RSF) == 0);                                /* Wait for clock ready																*/
;;;83     		
;;;84       SS = 0xFF - (RTC->SSR & 0xFF);
;;;85       T  = RTC->TR;
;;;86       D  = RTC->DR;
;;;87     
;;;88       if (SS != OldSS) 
;;;89       {
;;;90         ms = 0;
;;;91       }
;;;92       else 
;;;93       {
;;;94         ms = __usat(ms + 1, 2);
;;;95       }
;;;96       OldSS = SS;
;;;97       
;;;98     	*RtcTime = (T & 0x003FFFFF) | ((((SS * 1000) << 14) + (ms << 22)) & 0xFFC00000);      /* Время + миллисекунды */
;;;99     	*RtcDate = D | (SS << 24);                                                            /* Дата + ssc           */
;;;100    	
;;;101      RTC->ISR = ~RTC_ISR_RSF;
;;;102    	return 1;
;;;103    #else
;;;104    	return 0;
;;;105    #endif	
;;;106    }
0002f4  bf04              ITT      EQ
0002f6  bc70              POPEQ    {r4-r6}
0002f8  4770              BXEQ     lr
                  |L1.762|
0002fa  6818              LDR      r0,[r3,#0]            ;82
0002fc  f0100f20          TST      r0,#0x20              ;82
000300  d0fb              BEQ      |L1.762|
000302  f6420028          MOV      r0,#0x2828            ;84
000306  f2c40000          MOVT     r0,#0x4000            ;84
00030a  6800              LDR      r0,[r0,#0]            ;84
00030c  f44f5c20          MOV      r12,#0x2800           ;85
000310  f2c40c00          MOVT     r12,#0x4000           ;85
000314  b2c0              UXTB     r0,r0                 ;84
000316  f8dc5000          LDR      r5,[r12,#0]           ;85
00031a  f1c000ff          RSB      r0,r0,#0xff           ;84
00031e  f10c0c04          ADD      r12,r12,#4            ;86
000322  f8dc4000          LDR      r4,[r12,#0]           ;86
000326  f2400c00          MOVW     r12,#:LOWER16: ||area_number.5||;88
00032a  f2c00c00          MOVT     r12,#:UPPER16: ||area_number.5||;88
00032e  f8dc6000          LDR      r6,[r12,#0]           ;88  ; OldSS
000332  42b0              CMP      r0,r6                 ;88
000334  bf18              IT       NE                    ;90
000336  2600              MOVNE    r6,#0                 ;90
000338  d104              BNE      |L1.836|
00033a  f8dc6004          LDR      r6,[r12,#4]           ;94  ; ms
00033e  1c76              ADDS     r6,r6,#1              ;94
000340  f3860602          USAT     r6,#2,r6              ;94
                  |L1.836|
000344  f8cc6004          STR      r6,[r12,#4]           ;98  ; ms
000348  f8cc0000          STR      r0,[r12,#0]           ;98  ; OldSS
00034c  f44f067a          MOV      r6,#0xfa0000          ;98
000350  4346              MULS     r6,r0,r6              ;98
000352  f8bcc004          LDRH     r12,[r12,#4]          ;98  ; ms
000356  f3c50515          UBFX     r5,r5,#0,#22          ;98
00035a  eb065c8c          ADD      r12,r6,r12,LSL #22    ;98
00035e  f42c1c78          BIC      r12,r12,#0x3e0000     ;98
000362  ea4c0c05          ORR      r12,r12,r5            ;98
000366  ea446000          ORR      r0,r4,r0,LSL #24      ;99
00036a  f8c2c000          STR      r12,[r2,#0]           ;99
00036e  6008              STR      r0,[r1,#0]            ;101
000370  f06f0020          MVN      r0,#0x20              ;101
000374  6018              STR      r0,[r3,#0]            ;101
000376  bc70              POP      {r4-r6}
000378  2001              MOVS     r0,#1                 ;102
00037a  4770              BX       lr
;;;107    
                          ENDP

                  |L1.892|
00037c  1f1d1f1e          DCB      31,29,31,30,31,30,31,31,30,31,30,31
000380  1f1e1f1f
000384  1e1f1e1f

                          AREA ||.data||, DATA, ALIGN=2

                  RTC_OK
                          DCD      0x00000000

                          AREA ||area_number.5||, DATA, ALIGN=2

                          EXPORTAS ||area_number.5||, ||.data||
                  OldSS
                          DCD      0xffffffff
                  ||ms||
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "PERIPH\\rtc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_rtc_c_RTC_OK____REV16|
#line 129 ".\\STARTUP\\core_cmInstr.h"
|__asm___5_rtc_c_RTC_OK____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_rtc_c_RTC_OK____REVSH|
#line 144
|__asm___5_rtc_c_RTC_OK____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
